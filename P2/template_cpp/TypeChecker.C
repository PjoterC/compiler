/* File generated by the BNF Converter (bnfc 2.9.5). */

/*** Visitor Design Pattern TypeChecker. ***/
/* This implements the common visitor design pattern.
   Note that this method uses Visitor-traversal of lists, so
   List->accept() does NOT traverse the list. This allows different
   algorithms to use context information differently. */

#include "TypeChecker.H"


void TypeChecker::pushScope()
{
	context.vars.push_back({});
  //std::cout << "Pushed new scope, current scope size: " << context.vars.size() << std::endl; //debug

}

void TypeChecker::popScope()
{
	context.vars.pop_back();
  //std::cout << "Popped scope, current scope size: " << context.vars.size() << std::endl; //debug
}

void TypeChecker::addFn(const Id &id, const FnType &type)
{
	context.globals.fns[id] = type;
}

void TypeChecker::addSt(const Id &id, const StType &type)
{
	context.globals.sts[id] = type;
}

void TypeChecker::addVa(const Id &id, const VaType &type)
{
	context.vars.back()[id] = type;
}

const FnType* TypeChecker::findFn(const Id &id)
{

	auto it = context.globals.fns.find(id);
	if (it == context.globals.fns.end())
	{
		return nullptr; // Return nullptr if the function is not found
	}
	return &it->second;
}

const StType* TypeChecker::findSt(const Id &id)
{

	auto it = context.globals.sts.find(id);
	if (it == context.globals.sts.end())
	{
		return nullptr; // Return nullptr if the struct is not found
	}
	return &it->second;

}

const VaType* TypeChecker::findVa(const Id &id) //needs checking upper scopes
{

	auto it = context.vars.back().find(id);
	if (it == context.vars.back().end())
	{
    // If not found in the current scope, search in outer scopes
    for (auto it_scope = context.vars.rbegin() + 1; it_scope != context.vars.rend(); ++it_scope) {
      auto it_outer = it_scope->find(id);
      if (it_outer != it_scope->end()) {
        return &it_outer->second; // Found in an outer scope
      }
    }
    return nullptr; // Not found in any scope
	}
	return &it->second;
}


 const VaType* TypeChecker::findVaInCurrentScope(const Id &id) const{
    auto it = context.vars.back().find(id);
    if (it == context.vars.back().end()) {
        return nullptr; // Return nullptr if the variable is not found in the current scope
    }
    return &it->second;
 }


std::string TypeChecker::typeToString(const Type* t) const {
  if (t == nullptr) {
    return "null";
  }

  if (auto type_int = dynamic_cast<const Type_int*>(t)) {
    return "int";
  } else if (auto type_bool = dynamic_cast<const Type_bool*>(t)) {
    return "bool";
  } else if (auto type_double = dynamic_cast<const Type_double*>(t)) {
    return "double";
  } else if (auto type_void = dynamic_cast<const Type_void*>(t)) {
    return "void";
  } else if (auto type_exception = dynamic_cast<const Type_exception*>(t)) {
    return "exception";
  } else if (auto type_id = dynamic_cast<const TypeId*>(t)) {
    return "TypeId: " + type_id->id_;
  }

  return "unknown"; // Fallback for unrecognized types
}


bool TypeChecker::typesEqual(const Type* a, const Type* b) {
  if (a == nullptr || b == nullptr) {
    auto t1 = typeToString(a);
    auto t2 = typeToString(b);
    std::cerr << "Error: One of the types is null. (" << t1 << ", " << t2 << ")" << std::endl;
    exit(1); // Or your preferred error handling
    //throw std::runtime_error("Unrecognized type");
  }
std::cout << "Comparing types: " << typeToString(a) << " and " << typeToString(b) << std::endl; //debug
  if (typeid(*a) != typeid(*b)) {
    return false; // Different kinds of types
  }


  // Now compare based on actual type kind
  if (auto ta = dynamic_cast<const Type_int*>(a)) {
    //std::cout << "Comparing Type_int" << std::endl; //debug
    return dynamic_cast<const Type_int*>(b) != nullptr;
  } else if (auto ta = dynamic_cast<const Type_bool*>(a)) {
    //std::cout << "Comparing Type_bool" << std::endl; //debug
    return dynamic_cast<const Type_bool*>(b) != nullptr;
  } else if (auto ta = dynamic_cast<const Type_double*>(a)) {
    //std::cout << "Comparing Type_double" << std::endl; //debug
    return dynamic_cast<const Type_double*>(b) != nullptr;
  } else if (auto ta = dynamic_cast<const TypeId*>(a)) {
    //std::cout << "Comparing TypeId: " << ta->id_ << std::endl; //debug
    auto tb = dynamic_cast<const TypeId*>(b);
    return tb && ta->id_ == tb->id_; // compare names of custom types
  }
    else if(auto ta = dynamic_cast<const Type_void*>(a)) {
      return dynamic_cast<const Type_void*>(b) != nullptr;
    }
    else if(auto ta = dynamic_cast<const Type_exception*>(a)) {
      return dynamic_cast<const Type_exception*>(b) != nullptr;
    }



  return false; // fallback
}

bool TypeChecker::isNumeric(const Type* t) const {
  if (t == nullptr) {
    std::cerr << "Error: Type is null." << std::endl;
    exit(1); // Or your preferred error handling
    //throw std::runtime_error("Type is null");
  }

  return dynamic_cast<const Type_int*>(t) || dynamic_cast<const Type_double*>(t);
}

bool TypeChecker::isLValue(Exp* e) {
    if (auto* eid = dynamic_cast<EId*>(e)) {
        // Check if the identifier refers to a variable
        return findVa(eid->id_) != nullptr;
    }

    // Structure projections are also valid l-values
    if (dynamic_cast<EProj*>(e)) {
        return true;
    }

    return false;
}


void TypeChecker::visitProgram(Program *t){

}
void TypeChecker::visitDef(Def *t) {} //abstract class
void TypeChecker::visitField(Field *t) {} //abstract class
void TypeChecker::visitArg(Arg *t) {} //abstract class
void TypeChecker::visitStm(Stm *t) {} //abstract class
void TypeChecker::visitIdIn(IdIn *t) {} //abstract class
void TypeChecker::visitExp(Exp *t) {} //abstract class
void TypeChecker::visitType(Type *t) {} //abstract class


void TypeChecker::run(Program* p){
    if (auto* p_defs = dynamic_cast<PDefs*>(p)) {
    p_defs->accept(this);
  } else {
    std::cerr << "Error: Program must be a PDefs instance." << std::endl;
  }
}


void TypeChecker::visitPDefs(PDefs *p_defs) { //StructDer needs fixing (optional)

    for (Def* def : *p_defs->listdef_) {

        if (auto* f_def = dynamic_cast<DFun*>(def)) {
           // std::cout << "Processing function definition: " << f_def->id_ << std::endl; //debug
            // Handle function declaration
            Id fname = f_def->id_;
            if (context.globals.fns.count(fname)) {
                std::cerr << "Error: Redefinition of function '" << fname << "'." << std::endl;
                exit(1); // Or your preferred error handling
                //throw std::runtime_error("Error: Redefinition of function '" + fname + "'.");

            }

            std::vector<const Type*> argTypes;
            if (f_def->listarg_) {
                for (Arg* arg : *f_def->listarg_) {
                    ADecl* a_decl = dynamic_cast<ADecl*>(arg);
                    if (a_decl && a_decl->type_) {
                        argTypes.push_back(a_decl->type_);
                    }
                }
            }

            context.globals.fns[fname] = FnType{ f_def->type_, argTypes };

        } else if (auto* d_struct = dynamic_cast<DStruct*>(def)) {
    Id sid = d_struct->id_;  // Struct name

    // Check for duplicate struct definitions
    if (context.globals.sts.count(sid)) {
        std::cerr << "Error: Redefinition of struct '" << sid << "'." << std::endl;
        exit(1); // Or your preferred error handling
        //throw std::runtime_error("Error: Redefinition of struct '" + sid + "'.");
    }

    std::map<Id, const Type*> fields;

    // Iterate through struct fields
    if (d_struct->listfield_) {
        for (Field* field : *d_struct->listfield_) {
            auto* fdecl = dynamic_cast<FDecl*>(field);
            if (fdecl) {
                Id fid = fdecl->id_;
                const Type* ftype = fdecl->type_;

                // Check for duplicate field names in the same struct
                if (fields.count(fid)) {
                    std::cerr << "Error: Duplicate field '" << fid << "' in struct '" << sid << "'." << std::endl;
                    exit(1); // Or your preferred error handling
                    //throw std::runtime_error("Error: Duplicate field '" + fid + "' in struct '" + sid + "'.");
                }

                fields[fid] = ftype;
            } else {
              std::cerr << "Error: Unsupported field type in struct '" << sid << "'." << std::endl;
              exit(1);

              //throw std::runtime_error("Unsupported field type in struct '" + sid + "'.");
            }
        }
    }

    // Register struct in global context
    context.globals.sts[sid] = StType{false, false, fields};

} else if (auto* d_struct_der = dynamic_cast<DStructDer*>(def)) {
            // Handle derived struct
            Id sid = d_struct_der->id_;
            if (context.globals.sts.count(sid)) {
                std::cerr << "Error: Redefinition of derived struct '" << sid << "'." << std::endl;
                continue;
            }

            std::map<Id, const Type*> fields;
            if (d_struct_der->listfield_) {
                for (Field* field : *d_struct_der->listfield_) {
                    auto* fdecl = dynamic_cast<FDecl*>(field);
                    if (fdecl) {
                        fields[fdecl->id_] = fdecl->type_;
                    }
                }
            }

            context.globals.sts[sid] = StType{true, false, fields};
        }
    }

    /* std::cout << "Found functions: " << std::endl; //debug
    for (const auto& fn : context.globals.fns) {
        std::cout << "Function: " << typeToString(fn.second.ret) << " " << fn.first << std::endl; //debug
    }
    //std::cout << "Found structs: " << std::endl; //debug
    for (const auto& st : context.globals.sts) {
        //std::cout << "Struct: " << st.first << std::endl; //debug
    } */

    //fill the fields of derived structs
    for (Def* def : *p_defs->listdef_) {
        if (auto* d_struct_der = dynamic_cast<DStructDer*>(def)) {
            Id sid = d_struct_der->id_;
            auto parentType = dynamic_cast<const TypeId*>(d_struct_der->type_);
            if (parentType) {
                auto parentData = findSt(parentType->id_);
                if (!parentData) {
                    std::cerr << "TYPE ERROR: Base struct '" << parentType->id_
                              << "' not found for derived struct '" << sid << "'\n";
                    exit(1);
                }
                if (parentData->isException) {
                    context.globals.sts[sid].isException = true;
                }
                for (const auto& member : parentData->members) {
                    if (context.globals.sts[sid].members.count(member.first)) {
                        std::cerr << "TYPE ERROR: Field '" << member.first
                                  << "' already exists in derived struct '" << sid << "'\n";
                        exit(1);
                    }
                    context.globals.sts[sid].members[member.first] = member.second;
                }
            }
            else if (typesEqual(d_struct_der->type_, getExceptionType())) {
                context.globals.sts[sid].isException = true;
            }
            else {
                std::cerr << "TYPE ERROR: Base type for derived struct '" << sid
                          << "' is not a valid struct or exception type\n";
                exit(1);
            }
        }
    }



    // After collecting, type check everything
     for (Def* def : *p_defs->listdef_) {
    //std::cout << "Visiting definition: " << std::endl; //debug
        def->accept(this);
    }
}

void TypeChecker::visitDFun(DFun *d_fun) //done
{

  pushScope();
  returnType_ = d_fun->type_; // Set the current function return type
  std::cout << "Visiting function definition: " << typeToString(returnType_) << " " <<d_fun->id_ << std::endl; //debug
    // Add arguments to current scope
    if (d_fun->listarg_) {
        for (Arg* arg : *d_fun->listarg_) {
            arg->accept(this);
        }
    }

    // Check function body
    if (d_fun->liststm_) {
      for (Stm* stm : *d_fun->liststm_) {
        std::cout << "Visiting statement in function: " << d_fun->id_ << std::endl; //debug
        stm->accept(this);
      }
    }
    std::cout << "variables in scope after function declaration: " << std::endl; //debug
    for (const auto& var : context.vars.back()) {
        std::cout << "Variable: " << var.first << " of type: " << typeToString(var.second.type) << std::endl; //debug
    }
    popScope();

}

void TypeChecker::visitDStruct(DStruct *d_struct) //done?
{
  pushScope(); // Enter a new scope for the struct

  Id sid = d_struct->id_;

  if (d_struct->listfield_) {
    std::map<Id, const Type*>* members = &context.globals.sts[sid].members;
    for(auto member : *members) {

      addVa(member.first, VaType{member.second});
      std::cout << "Added variable to struct scope: " << member.first  << std::endl; //debug
    }
  }

  if (d_struct->listfield_) d_struct->listfield_->accept(this);
  popScope(); // Exit the scope after processing the struct

}

void TypeChecker::visitDStructDer(DStructDer *d_struct_der) //done?
{

   pushScope(); // Enter a new scope for the struct

  //Add all fields to the current scope
  Id sid = d_struct_der->id_;
  d_struct_der->type_->accept(this); // Visit the base type to ensure it exists


  if (d_struct_der->listfield_) {
    std::map<Id, const Type*>* members = &context.globals.sts[sid].members;
    for(auto member : *members) {
      if(findVa(member.first)) {
        std::cerr << "TYPE ERROR: Field '" << member.first << "' already exists '" << sid << "'." << std::endl;
        exit(1);
      }
      addVa(member.first, VaType{member.second});

    }
  }


  if (d_struct_der->listfield_) d_struct_der->listfield_->accept(this);
  popScope(); // Exit the scope after processing the struct


}

void TypeChecker::visitFDecl(FDecl *f_decl)
{
  /* Code For FDecl Goes Here */

  if (f_decl->type_) f_decl->type_->accept(this);
  visitId(f_decl->id_);


}

void TypeChecker::visitADecl(ADecl *a_decl)
{
    std::cout << "Visiting argument declaration: " << a_decl->id_ << std::endl; // debug

    // Visit type (e.g., to resolve type aliases or validate struct existence)
    if (a_decl->type_) {
        a_decl->type_->accept(this);
    }
    if (typesEqual(a_decl->type_, typeVoid_)) {
    std::cerr << "TYPE ERROR: argument '" << a_decl->id_ << "' cannot have type void." << std::endl;
    exit(1);
}

    // Check for redeclaration in the current scope
    Scope& scope = context.vars.back();
    if (scope.find(a_decl->id_) != scope.end()) {
        std::cerr << "TYPE ERROR: argument '" << a_decl->id_ << "' redeclared in the same scope." << std::endl;
        exit(1);
    }

    // Add variable to current scope
    addVa(a_decl->id_, VaType{a_decl->type_});

    std::cout << "Vars in scope after argument declaration: " << scope.size() << std::endl; // debug
}








void TypeChecker::visitSExp(SExp *s_exp)
{

    std::cout << "Visiting expression statement: " << std::endl; //debug
    // Make sure the expression exists
    if (s_exp->exp_) {
        s_exp->exp_->accept(this);  // Visit the inner expression
    }
       else {
        std::cerr << "Error: Empty expression statement." << std::endl;
        exit(1); // Or your preferred error handling
    }
}

void TypeChecker::visitSDecls(SDecls *s_decls)
{
    s_decls->type_->accept(this);

    if (typesEqual(s_decls->type_, typeVoid_)) {
        std::cerr << "TYPE ERROR: Declaration cannot have type void." << std::endl;
        exit(1);
    }

    const Type* declaredType = lastType_; // Store the resolved type

    if (!s_decls->listidin_) {
        std::cerr << "TYPE ERROR: SDecls must have a list of IdIn." << std::endl;
        exit(1);
    }

    for (IdIn* id_in : *s_decls->listidin_) {
        Id id;

        if (auto* id_no_init = dynamic_cast<IdNoInit*>(id_in)) {
            id = id_no_init->id_;
        } else if (auto* id_init = dynamic_cast<IdInit*>(id_in)) {
            id = id_init->id_;

            // Type check the initializing expression
            if (id_init->exp_) {
                id_init->exp_->accept(this);
                const Type* initType = lastType_;
                if (!typesEqual(declaredType, initType)) {
                    std::cerr << "TYPE ERROR: Variable '" << id
                              << "' initialized with incompatible type. "
                              << "Expected " << typeToString(declaredType)
                              << ", got " << typeToString(initType) << std::endl;
                    exit(1);
                }
            }
        } else {
            std::cerr << "TYPE ERROR: Unknown IdIn subclass in SDecls." << std::endl;
            exit(1);
        }

        if (findVaInCurrentScope(id)) {
            std::cerr << "TYPE ERROR: Variable '" << id << "' redeclared in the same scope." << std::endl;
            exit(1);
        }

        addVa(id, VaType{declaredType});
    }
}

void TypeChecker::visitSReturn(SReturn *s_return)
{
    if (!s_return->exp_) {
        std::cerr << "Error: return statement must have an expression." << std::endl;
        exit(1); // Or your preferred error handling
        //throw std::runtime_error("Error: return statement must have an expression.");
    }
    //std::cout << "Visiting return statement in a function " << std::endl; //debug

    // Evaluate the expression to determine its type
    s_return->exp_->accept(this);
    const Type* exprType = lastType_;  // assuming the expression sets its type here

    if (!typesEqual(returnType_, exprType)) {
        std::cerr << "Error: return type " << typeToString(exprType) << " does not match function return type " << typeToString(returnType_) << std::endl;
        exit(1); // Or your preferred error handling
        //throw std::runtime_error("Error: return type does not match function return type.");
    }
}

void TypeChecker::visitSReturnV(SReturnV *s_return_v)
{
    if (!typesEqual(returnType_, typeVoid_)) {
        std::cerr << "TYPE ERROR: return without value in a non-void function." << std::endl;
        exit(1);
    }

    lastType_ = typeVoid_;
}

void TypeChecker::visitSWhile(SWhile *s_while)
{

  if (s_while->exp_) s_while->exp_->accept(this);
  if (!typesEqual(lastType_, getBoolType()))
  {
    std::cerr << "Type error at while-loop condition: expected bool, got " << typeToString(lastType_) << std::endl;
    exit(1);
  }
  if (s_while->stm_) s_while->stm_->accept(this);

}

void TypeChecker::visitSDoWhile(SDoWhile *s_do_while)
{
  /* Code For SDoWhile Goes Here */

  if (s_do_while->stm_) s_do_while->stm_->accept(this);
  if (s_do_while->exp_) s_do_while->exp_->accept(this);
  if (!typesEqual(lastType_, getBoolType()))
  {
    std::cerr << "Type error at do-while-loop condition: expected bool, got " << typeToString(lastType_) << std::endl;
    exit(1);
  }

}

void TypeChecker::visitSFor(SFor *s_for)
{
  pushScope();

  if (s_for->exp_1) s_for->exp_1->accept(this);

  if (s_for->exp_2) {
    s_for->exp_2->accept(this);
    if (!typesEqual(lastType_, getBoolType()))
    {
      std::cerr << "Type error at for-loop condition: expected bool, got " << typeToString(lastType_) << std::endl;
      exit(1);
    }

  }

  if (s_for->exp_3) s_for->exp_3->accept(this);

  if (s_for->stm_) s_for->stm_->accept(this);

  popScope();



}

void TypeChecker::visitSBlock(SBlock *s_block)
{
    std::cout << "Visiting SBlock: entering a new scope." << std::endl; //debug
    pushScope();

    // Visit each statement in the block, if present
    if (s_block->liststm_) {
        for (Stm* stmt : *s_block->liststm_) {
          std::cout << "Visiting statement in block." << std::endl; //debug
            if (stmt) stmt->accept(this);
        }
    }
    else{
      //std::cout << "No statements found in block." << std::endl; //debug
    }

    // Exit the local scope
    popScope();
}

void TypeChecker::visitSIfElse(SIfElse *s_if_else)
{
    if (!s_if_else->exp_) {
        std::cerr << "TYPE ERROR: missing condition in if-statement\n";
        exit(1);
    }

    s_if_else->exp_->accept(this);

    if (!typesEqual(lastType_, getBoolType())) {
        std::cerr << "TYPE ERROR: condition of if-statement must be bool (got "
                  << typeToString(lastType_) << ")\n";
        exit(1);
    }

    pushScope();
    if (s_if_else->stm_1)
        s_if_else->stm_1->accept(this);
    popScope();

    pushScope();
    if (s_if_else->stm_2)
        s_if_else->stm_2->accept(this);
    popScope();

}


void TypeChecker::visitSTry(STry *s_try)
{
    if (s_try->stm_1)
        s_try->stm_1->accept(this);

    if (!s_try->type_) {
        std::cerr << "TYPE ERROR: Missing exception type in catch\n";
        exit(1);
    }
    s_try->type_->accept(this);
    const Type* catchType = lastType_;

    bool ok = typesEqual(catchType, getExceptionType());

    if (!ok) {
        if (auto tid = dynamic_cast<const TypeId*>(catchType)) {
            if (auto st = findSt(tid->id_)) {
                if (st->isException) {
                    ok = true;
                }
            }
        }
    }

    if (!ok) {
        std::cerr << "TYPE ERROR: catch parameter must be exception type\n";
        exit(1);
    }

    pushScope();
    addVa(s_try->id_, VaType{catchType});
    if (s_try->stm_2)
        s_try->stm_2->accept(this);
    popScope();
}


void TypeChecker::visitIdNoInit(IdNoInit *id_no_init) //needs current type tracking
{
  /* Code For IdNoInit Goes Here */
  //std::cout << "Visiting IdNoInit: " << id_no_init->id_ << std::endl; //debug
  visitId(id_no_init->id_);

}

void TypeChecker::visitIdInit(IdInit *id_init) //needs current type tracking
{
  /* Code For IdInit Goes Here */

  visitId(id_init->id_);
  if (id_init->exp_) id_init->exp_->accept(this);

}

void TypeChecker::visitETrue(ETrue *e_true) //needs globals to hold primitive types
{
  lastType_ = getBoolType(); // Set the current type to boolean


}

void TypeChecker::visitEFalse(EFalse *e_false) //needs globals to hold primitive types
{
  lastType_ = getBoolType(); // Set the current type to boolean


}

void TypeChecker::visitEInt(EInt *e_int)
{
  /* Code For EInt Goes Here */

  visitInteger(e_int->integer_);

}

void TypeChecker::visitEDouble(EDouble *e_double)
{
  /* Code For EDouble Goes Here */

  visitDouble(e_double->double_);

}

void TypeChecker::visitEId(EId *e_id)
{
  /* Code For EId Goes Here */
  //std::cout << "Visiting EId: " << e_id->id_ << std::endl; //debug
  visitId(e_id->id_);

}

void TypeChecker::visitEApp(EApp *e_app)
{
  //std::cout << "Visiting EApp: " << e_app->id_ << std::endl; //debug
    // Lookup the function
    const FnType* fn = findFn(e_app->id_);
    if (!fn) {
        std::cerr << "TYPE ERROR: function '" << e_app->id_ << "' is undefined." << std::endl;
        exit(1);
    }

    // Get the expected parameter types
    const auto& expectedArgs = fn->args;

    std::vector<const Type*> actualArgs;

    // Visit and collect argument types
    if (e_app->listexp_) {
        for (Exp* argExp : *e_app->listexp_) {
            argExp->accept(this);
            actualArgs.push_back(lastType_);
        }
    }

    // Check argument count
    if (expectedArgs.size() != actualArgs.size()) {
        std::cerr << "TYPE ERROR: function '" << e_app->id_
                  << "' expects " << expectedArgs.size()
                  << " arguments, but got " << actualArgs.size() << std::endl;
        exit(1);
    }

    // Check argument types
    for (size_t i = 0; i < expectedArgs.size(); ++i) {
        if (!typesEqual(expectedArgs[i], actualArgs[i])) {
            std::cerr << "TYPE ERROR: argument " << (i + 1)
                      << " of function '" << e_app->id_
                      << "' has incompatible type" << std::endl;
            exit(1);
        }
    }

    // Set return type
    lastType_ = fn->ret;
}


void TypeChecker::visitEProj(EProj *e_proj)
{
  if (e_proj->exp_) e_proj->exp_->accept(this);
  const Type* exprType = lastType_;
  std::cout << "Last type after visiting EProj expression: " << typeToString(exprType) << std::endl; //debug
    // Step 2: Check if it's a struct type
    const TypeId* structType = dynamic_cast<const TypeId*>(exprType);
    std::cout << "Id of struct type: " << (structType ? structType->id_ : "null") << std::endl; //debug
    if (!structType) {
        std::cerr << "TYPE ERROR: projection requires a struct type, but got something else." << std::endl;
        exit(1);
    }

 auto it = context.globals.sts.find(structType->id_);
    if (it == context.globals.sts.end()) {
        std::cerr << "TYPE ERROR: struct '" << structType->id_ << "' is not defined." << std::endl;
        exit(1);
    }

    const auto& members = it->second.members;

    // Step 4: Find the projected field
    auto fieldIt = members.find(e_proj->id_);
    if (fieldIt == members.end()) {
        std::cerr << "TYPE ERROR: struct '" << structType->id_
                  << "' has no field named '" << e_proj->id_ << "'." << std::endl;
        exit(1);
    }

    // Step 5: Set the result type
    lastType_ = fieldIt->second;
}

void TypeChecker::visitEPIncr(EPIncr *ep_incr)
{
    if (!isLValue(ep_incr->exp_)) {
        std::cerr << "TYPE ERROR: operand of 'x++' must be l-value\n";
        exit(1);
    }
    ep_incr->exp_->accept(this);
    if (dynamic_cast<const Type_double*>(lastType_)) {
        lastType_ = getDoubleType();
    } else if (dynamic_cast<const Type_int*>(lastType_)) {
        lastType_ = getIntType();
    } else {
        std::cerr << "TYPE ERROR: 'x++' operand must be numeric\n";
        exit(1);
    }
}

void TypeChecker::visitEPDecr(EPDecr *ep_decr)
{
    if (!isLValue(ep_decr->exp_)) {
        std::cerr << "TYPE ERROR: operand of 'x--' must be l-value\n";
        exit(1);
    }
    ep_decr->exp_->accept(this);
    if (dynamic_cast<const Type_double*>(lastType_)) {
        lastType_ = getDoubleType();
    } else if (dynamic_cast<const Type_int*>(lastType_)) {
        lastType_ = getIntType();
    } else {
        std::cerr << "TYPE ERROR: 'x--' operand must be numeric\n";
        exit(1);
    }
}

void TypeChecker::visitEIncr(EIncr *e_incr)
{
    if (!isLValue(e_incr->exp_)) {
        std::cerr << "TYPE ERROR: operand of '++x' must be l-value\n";
        exit(1);
    }
    e_incr->exp_->accept(this);
    if (dynamic_cast<const Type_double*>(lastType_)) {
        lastType_ = getDoubleType();
    } else if (dynamic_cast<const Type_int*>(lastType_)) {
        lastType_ = getIntType();
    } else {
        std::cerr << "TYPE ERROR: '++x' operand must be numeric\n";
        exit(1);
    }
}

void TypeChecker::visitEDecr(EDecr *e_decr)
{
    if (!isLValue(e_decr->exp_)) {
        std::cerr << "TYPE ERROR: operand of '--x' must be l-value\n";
        exit(1);
    }
    e_decr->exp_->accept(this);
    if (dynamic_cast<const Type_double*>(lastType_)) {
        lastType_ = getDoubleType();
    } else if (dynamic_cast<const Type_int*>(lastType_)) {
        lastType_ = getIntType();
    } else {
        std::cerr << "TYPE ERROR: '--x' operand must be numeric\n";
        exit(1);
    }
}

void TypeChecker::visitEUPlus(EUPlus *eu_plus)
{
    eu_plus->exp_->accept(this);
    if (dynamic_cast<const Type_double*>(lastType_)) {
        lastType_ = getDoubleType();
    } else if (dynamic_cast<const Type_int*>(lastType_)) {
        lastType_ = getIntType();
    } else {
        std::cerr << "TYPE ERROR: unary '+' operand must be numeric\n";
        exit(1);
    }
}

void TypeChecker::visitEUMinus(EUMinus *eu_minus)
{
    eu_minus->exp_->accept(this);
    if (dynamic_cast<const Type_double*>(lastType_)) {
        lastType_ = getDoubleType();
    } else if (dynamic_cast<const Type_int*>(lastType_)) {
        lastType_ = getIntType();
    } else {
        std::cerr << "TYPE ERROR: unary '-' operand must be numeric\n";
        exit(1);
    }
}


void TypeChecker::visitETimes(ETimes *e_times)
{
  /* Code For ETimes Goes Here */
  e_times->exp_1->accept(this);
  const Type* left = lastType_;

  e_times->exp_2->accept(this);
  const Type* right = lastType_;

  if (!isNumeric(left) || !isNumeric(right))
  {
    std::cerr << "Type error: '*' requires numeric operands (got "
                  << typeToString(left) << " and " << typeToString(right) << ")." << std::endl;
        exit(1);
  }

  if (typesEqual(left, getDoubleType()) || typesEqual(right, getDoubleType()))
  {
    lastType_ = getDoubleType();
  }else{
    lastType_ = getIntType();
  }



}

void TypeChecker::visitEDiv(EDiv *e_div)
{
    e_div->exp_1->accept(this);
    const Type* left = lastType_;

    e_div->exp_2->accept(this);
    const Type* right = lastType_;

    if (!isNumeric(left) || !isNumeric(right)) {
        std::cerr
            << "Type error: '/' requires numeric operands (got "
            << typeToString(left) << " and " << typeToString(right) << ")."
            << std::endl;
        exit(1);
    }

    if (typesEqual(left, getDoubleType()) || typesEqual(right, getDoubleType())) {
        lastType_ = getDoubleType();
    } else {
        lastType_ = getIntType();
    }
}

void TypeChecker::visitEPlus(EPlus *e_plus)
{
  /* Code For EPlus Goes Here */

  if (e_plus->exp_1) e_plus->exp_1->accept(this);
  const Type* leftType = lastType_;
  if (e_plus->exp_2) e_plus->exp_2->accept(this);
  const Type* rightType = lastType_;
  if (!isNumeric(leftType) || !isNumeric(rightType)) {
      std::cerr << "TYPE ERROR: addition operands must be numeric\n";
      exit(1);
  }
  if( typesEqual(leftType, getDoubleType()) || typesEqual(rightType, getDoubleType())) {
      lastType_ = getDoubleType();
  } else if (typesEqual(leftType, getIntType()) && typesEqual(rightType, getIntType())) {
      lastType_ = getIntType();
  } else {
      std::cerr << "TYPE ERROR: incompatible types in addition\n";
      exit(1);
  }
}

void TypeChecker::visitEMinus(EMinus *e_minus)
{


  if (e_minus->exp_1) e_minus->exp_1->accept(this);
  const Type* leftType = lastType_;
  if (e_minus->exp_2) e_minus->exp_2->accept(this);
  const Type* rightType = lastType_;
  if (!isNumeric(leftType) || !isNumeric(rightType)) {
      std::cerr << "TYPE ERROR: subtraction operands must be numeric\n";
      exit(1);
  }
  if( typesEqual(leftType, getDoubleType()) || typesEqual(rightType, getDoubleType())) {
      lastType_ = getDoubleType();
  } else if (typesEqual(leftType, getIntType()) && typesEqual(rightType, getIntType())) {
      lastType_ = getIntType();
  } else {
      std::cerr << "TYPE ERROR: incompatible types in subtraction\n";
      exit(1);
  }

}
void TypeChecker::visitETwc(ETwc *e_twc)
{
    e_twc->exp_1->accept(this);
    const Type* leftType = lastType_;

    e_twc->exp_2->accept(this);
    const Type* rightType = lastType_;

    if (!isNumeric(leftType) || !isNumeric(rightType)) {
        std::cerr << "TYPE ERROR: three-way comparison operands must be numeric\n";
        exit(1);
    }

    bool same = typesEqual(leftType, rightType);
    bool intToDouble = typesEqual(leftType, getDoubleType()) && typesEqual(rightType, getIntType());
    bool doubleToInt = typesEqual(leftType, getIntType()) && typesEqual(rightType, getDoubleType());
    if (!(same || intToDouble || doubleToInt)) {
        std::cerr << "TYPE ERROR: incompatible types in three-way comparison\n";
        exit(1);
    }

    lastType_ = getIntType();
}


void TypeChecker::visitELt(ELt *e_lt)
{
  if (e_lt->exp_1) e_lt->exp_1->accept(this);
  const Type* firstType = lastType_;
  if (e_lt->exp_2) e_lt->exp_2->accept(this);
  const Type* secondType = lastType_;
  if (!isNumeric(firstType) || !isNumeric(secondType)) {
      std::cerr << "TYPE ERROR: '<' requires numeric operands (got "
                << typeToString(firstType) << " and " << typeToString(secondType) << ")." << std::endl;
      exit(1);
  }
  
  lastType_ = getBoolType(); // Set the result type to boolean
}

void TypeChecker::visitEGt(EGt *e_gt)
{
  if (e_gt->exp_1) e_gt->exp_1->accept(this);
  const Type* firstType = lastType_;
  if (e_gt->exp_2) e_gt->exp_2->accept(this);
  const Type* secondType = lastType_;
  if (!isNumeric(firstType) || !isNumeric(secondType)) {
      std::cerr << "TYPE ERROR: '>' requires numeric operands (got "
                << typeToString(firstType) << " and " << typeToString(secondType) << ")." << std::endl;
      exit(1);
  }

  lastType_ = getBoolType(); // Set the result type to boolean
}
void TypeChecker::visitELtEq(ELtEq *e_lt_eq)
{
  /* Code For ELtEq Goes Here */
  e_lt_eq->exp_1->accept(this);
  const Type* left = lastType_;

  e_lt_eq->exp_2->accept(this);
  const Type* right = lastType_;

  if (!isNumeric(left) || !isNumeric(right))
  {
   std::cerr << "Type error: '<=' requires numeric operands (got " << typeToString(left) << " and " << typeToString(right) << ")." << std::endl;
   exit(1);
  }

lastType_ = getBoolType();

}

void TypeChecker::visitEGtEq(EGtEq *e_gt_eq)
{
    e_gt_eq->exp_1->accept(this);
    const Type* left = lastType_;

    e_gt_eq->exp_2->accept(this);
    const Type* right = lastType_;

    if (!isNumeric(left) || !isNumeric(right)) {
        std::cerr
            << "Type error: '>=' requires numeric operands (got "
            << typeToString(left) << " and " << typeToString(right) << ")."
            << std::endl;
        exit(1);
    }

    lastType_ = getBoolType();
}

void TypeChecker::visitEEq(EEq *e_eq)
{
  if(e_eq->exp_1) e_eq->exp_1->accept(this);

  if(e_eq->exp_2) e_eq->exp_2->accept(this);



  lastType_ = getBoolType();

}

void TypeChecker::visitENEq(ENEq *en_eq)
{
  if(en_eq->exp_1) en_eq->exp_1->accept(this);

  if(en_eq->exp_2) en_eq->exp_2->accept(this);


lastType_ = getBoolType();
}

void TypeChecker::visitEAnd(EAnd *e_and)
{
    e_and->exp_1->accept(this);
    if (!typesEqual(lastType_, getBoolType())) {
        std::cerr << "TYPE ERROR: Left operand of '&&' must be of type bool." << std::endl;
        exit(1);
    }

    e_and->exp_2->accept(this);
    if (!typesEqual(lastType_, getBoolType())) {
        std::cerr << "TYPE ERROR: Right operand of '&&' must be of type bool." << std::endl;
        exit(1);
    }

    lastType_ = getBoolType(); // boolean result
}

void TypeChecker::visitEOr(EOr *e_or)
{
    e_or->exp_1->accept(this);
    if (!typesEqual(lastType_, getBoolType())) {
        std::cerr << "TYPE ERROR: Left operand of '||' must be of type bool." << std::endl;
        exit(1);
    }

    e_or->exp_2->accept(this);
    if (!typesEqual(lastType_, getBoolType())) {
        std::cerr << "TYPE ERROR: Right operand of '||' must be of type bool." << std::endl;
        exit(1);
    }

    lastType_ = getBoolType(); // boolean result

}

void TypeChecker::visitEAss(EAss *e_ass)
{

  //std::cout << "Visiting EAssignment" << std::endl; //debug

if (!isLValue(e_ass->exp_1)) {
        std::cerr << "TYPE ERROR: Left-hand side of assignment is not assignable (not an l-value)." << std::endl;
        exit(1);
    }
  if (e_ass->exp_1) e_ass->exp_1->accept(this);
  auto firstType = lastType_;


  //std::cout << "First type: " << firstType << std::endl; //debug
  if (e_ass->exp_2) e_ass->exp_2->accept(this);
  auto secondType = lastType_;
  //std::cout << "Second type: " << secondType << std::endl; //debug
  if(!(dynamic_cast<const Type_double*>(firstType) && dynamic_cast<const Type_int*>(secondType))){
    if (!typesEqual(firstType, secondType)) {
        std::cerr << "TYPE ERROR: incompatible types in assignment\n";
        exit(1);
    }
  }
  lastType_ = firstType;
}

void TypeChecker::visitECond(ECond *e_cond)
{


  if (e_cond->exp_1) e_cond->exp_1->accept(this);
  auto firstType = lastType_;
  std::cout << typeToString(firstType) << std::endl;
  if (e_cond->exp_2) e_cond->exp_2->accept(this);
  auto secondType = lastType_;
  if (e_cond->exp_3) e_cond->exp_3->accept(this);
  auto thirdType = lastType_;

  if(typesEqual(firstType, getBoolType()) && typesEqual(secondType, thirdType)) {
      lastType_ = secondType;
  } else {
      std::cerr << "TYPE ERROR: Invalid type in conditional expression\n";
      exit(1);
  }
}

void TypeChecker::visitEThrow(EThrow *e_throw)
{
    if (!e_throw->exp_) {
        std::cerr << "TYPE ERROR: throw expression is missing\n";
        exit(1);
    }

    e_throw->exp_->accept(this);
    const Type* thrownType = lastType_;

    bool ok = false;

    if (typesEqual(thrownType, getExceptionType())) {
        ok = true;
    }
    else if (auto tid = dynamic_cast<const TypeId*>(thrownType)) {
        auto st = findSt(tid->id_);
        if (st && st->isException) {
            ok = true;
        }
    }

    if (!ok) {
        std::cerr << "TYPE ERROR: Throw expression must be of type 'exception'\n";
        exit(1);
    }

    lastType_ = getExceptionType();
}



// visitType_X: Just remember we found type X
void TypeChecker::visitType_bool(Type_bool *)
{
    lastType_ = typeBool_;
}

void TypeChecker::visitType_int(Type_int *)
{
    lastType_ = typeInt_;
}

void TypeChecker::visitType_double(Type_double *)
{
    lastType_ = typeDouble_;
}

void TypeChecker::visitType_void(Type_void *)
{
    lastType_ = typeVoid_;
}

void TypeChecker::visitType_exception(Type_exception *)
{
    //std::cout << "Visiting Type_exception" << std::endl; //debug
    lastType_ = typeException_;
}

// visitTypeId: type defined by a user (for example struct)
// We check if the given name appears in the struct table.
// if so, we consider it a valid type and set lastType_ to the AST object TypeId.
// Otherwise, we throw an error.
void TypeChecker::visitTypeId(TypeId *p)
{
    //std::cout << "Visiting TypeId: " << p->id_ << std::endl; //debug
    // p->id_ is the id of the type name
    const StType* st = findSt(p->id_);
    if (!st) {
        std::cerr
            << "TYPE ERROR: unknown struct type '" << p->id_ << "'\n";
        exit(1);
    }

    lastType_ = p;
}


void TypeChecker::visitListDef(ListDef *list_def)
{
  for (ListDef::iterator i = list_def->begin() ; i != list_def->end() ; ++i)
  {
    (*i)->accept(this);
  }
}

void TypeChecker::visitListField(ListField *list_field)
{
  for (ListField::iterator i = list_field->begin() ; i != list_field->end() ; ++i)
  {
    (*i)->accept(this);
  }
}

void TypeChecker::visitListArg(ListArg *list_arg)
{
  for (ListArg::iterator i = list_arg->begin() ; i != list_arg->end() ; ++i)
  {
    (*i)->accept(this);
  }
}

void TypeChecker::visitListStm(ListStm *list_stm)
{
  for (ListStm::iterator i = list_stm->begin() ; i != list_stm->end() ; ++i)
  {
    (*i)->accept(this);
  }
}

void TypeChecker::visitListIdIn(ListIdIn *list_id_in)
{
  for (ListIdIn::iterator i = list_id_in->begin() ; i != list_id_in->end() ; ++i)
  {
    (*i)->accept(this);
  }
}

void TypeChecker::visitListExp(ListExp *list_exp)
{
  for (ListExp::iterator i = list_exp->begin() ; i != list_exp->end() ; ++i)
  {
    (*i)->accept(this);
  }
}

void TypeChecker::visitListId(ListId *list_id)
{
  for (ListId::iterator i = list_id->begin() ; i != list_id->end() ; ++i)
  {
    visitId(*i) ;
  }
}


// visitX: methods for literal expressions
void TypeChecker::visitInteger(Integer)
{
    lastType_ = getIntType(); // Set the current type to integer
}

void TypeChecker::visitChar(Char)
{
    lastType_ = getIntType(); // Set the current type to integer (no char type in specification)
}

void TypeChecker::visitDouble(Double)
{
    lastType_ = getDoubleType(); // Set the current type to double
}

// There is no string type in specification
void TypeChecker::visitString(String)
{
    std::cerr
        << "TYPE ERROR: string literals are not supported in this language\n";
    exit(1);
}

void TypeChecker::visitIdent(Ident x)
{
    std::cerr
        << "TYPE ERROR: unexpected bare identifier '" << x << "'\n";
    exit(1);
}


void TypeChecker::visitId(Id x)
{
     //std::cout << "Visiting Id: " << x << std::endl; //debug
    auto* va = findVa(x);
    auto* fn = findFn(x);
    auto* st = findSt(x);

    if (va) {
        lastType_ = va->type;
    } else if (fn) {
        lastType_ = fn->ret;
    } else if (st) {
        lastType_ = new TypeId(x);
    } else {
        std::cerr << "TYPE ERROR: unknown identifier '" << x << "'\n";
        exit(1);
    }
}
